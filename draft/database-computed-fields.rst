==========================================
DEP XXXX: Readonly and Auto-Refresh Fields
==========================================

:DEP: XXXX
:Author: Ben Cole, Joachim Jablon
:Implementation Team: Ben Cole, Joachim Jablon
:Shepherd: Josh Smeaton
:Status: Draft
:Type: Feature
:Created: 2016-11-08
:Last-Modified: 2016-11-13

.. contents:: Table of Contents
   :depth: 3
   :local:

Abstract
========

This DEP defines 2 new properties of Model Fields:

- ``readonly`` keeps Django from trying to write the value of those Fields to the database, either at creation time, update time or both;
- ``auto_refresh`` makes Django aware that, when creating and/or updating an object, the value of this Field will need to be fetched from the database.

The addition of those two features will mainly help two different use-cases. Firstly, it will help people who use databases that define their own values for some field (e.g. triggers automatically modifying the value of a column, database views, ...). Secondly, it will provide a simpler baseline for the implementation of advanced database features within Django (database-side default values, simplifying and expanding ``AutoField``, ...).

Specification
=============

There are two distinct parts in this DEP: Readonly and Auto-Refresh

Readonly
--------

Of the two features described in this DEP, readonly should be the simplest one.
It boils down to the following: when a ``Field`` is marked readonly, Django will not write its value to the database, ever.

It will be done by removing these field at the SQL compiler level.

Note: the described specification has already been partially implemented (see the `Existing works`_ section).

API
^^^

The proposed API would be :

.. code-block:: python

    class Book(models.Model):
        always_readonly = models.IntegerField(readonly=True)  # or "all"
        readonly_at_creation = models.IntegerField(readonly="create")
        readonly_at_update = models.IntegerField(readonly="update")

        # And of course
        not_readonly = models.IntegerField(readonly=False)
        not_readonly_either = models.IntegerField()

Setting the value
^^^^^^^^^^^^^^^^^

We suggest creating a ``readonly`` property in the ``Field`` class. This property would have a ``False`` value at class level. There would be a keyword argument in the ``Field`` constructor, allowing to set this property to ``True`` on instance level.

Using the value
^^^^^^^^^^^^^^^

``readonly`` will be implemented by modifying the SQL compilers to make them "forget" about readonly fields, specifically for ``INSERT`` and ``UPDATE`` queries.

In the ``SQLInsertCompiler`` class, the ``as_sql`` method manipulates ``self.query.fields``. We would change the implementation so that it would ignore the readonly fields (those whose readonly value is either ``True`` or ``"create"``).

In the ``SQLUpdateCompiler`` class, the ``as_sql`` method manipulates ``self.query.values`` which is a list of tuples whose first values are ``Field`` instances. We would change the implementation so that it would ignore the readonly fields (those whose readonly value is either ``True`` or ``"update"``).

Warning for misuses
^^^^^^^^^^^^^^^^^^^

We would log a ``warning`` (``logging.getLogger("django.db.models.readonly").warn()``) when calling :

- ``Model(readonly=...)``
- ``Model().readonly = ...``
- ``Model.objects.update(readonly=...)``
- ``Model.objects.save(update_fields=["readonly"])``

(where ``readonly`` is the name on any ``Field`` marked readonly).

Serialization
^^^^^^^^^^^^^

Readonly fields would be included in serialization but silently excluded from deserialization. No warning would be logged.

Empty queries
^^^^^^^^^^^^^

If a query becomes empty because all its fields are actually readonly, it should not be executed. This is already the case in the compilers, but this behaviour will be kept.

Auto-Refresh
------------

This part describes the Auto-refresh feature that will specify how, when field values are generated by the database, Django will fetch them and put them on their instances after a call to ``.save()``, ``Model.objects.create()``, and such.

This will be done in the same query for the databases that support the ``RETURNING`` keyword. For other databases, it will be done by marking the field as ``deferred``. This way, the first time users try to access the value of a readonly field, it will be fetched from the database. Users may do an ``instance.refresh_from_db(readonly=True)`` to fetch them all with a single query.

Auto-refresh will be available selectively at creation, at update or both (or none, of course).

API
^^^

The proposed API would be:

.. code-block:: python

    class Book(models.Model):
        refresh = models.IntegerField(auto_refresh=True)  # or "all"
        refresh_at_creation = models.IntegerField(auto_refresh="create")
        refresh_at_update = models.IntegerField(auto_refresh="update")

        # And of course
        no_refresh = models.IntegerField(auto_refresh=False)
        no_refresh_either = models.IntegerField()


At this step, a complete implementation specification is not proposed, but existing Pull Requests (see `Existing works`_) may provide good leads on how to complete this DEP.

The ``refresh_from_db`` Model instance method will have an optional keyword argument named ``readonly`` that will allow refreshing all the auto-refresh fields in one go.

Motivation
==========

Django is a practical tool for interacting with a database but, as of today and with a few exceptions, it mainly considers that Databases are just storage systems. Several features provided by various databases really start to make sense when considering they are not just data stores but also actors on the data.

The main consequence of this is that part or all of the responsibility for some fields should not rest on Django, but on the database. This implies two different things :

- Django should not try to write some fields to the database when doing an ``INSERT`` and/or an ``UPDATE`` because that would overwrite values that the Database may have been put there (readonly).
- When creating or updating values, Django should somehow fetch the value from the database for these fields specifically, because their value on the Database makes much more sense than the one on the model instance (auto-refresh).

These two behaviours are functionally independent but both are needed in many cases. More precisely, most cases that use ``readonly`` might also benefit from ``auto_refresh``.

It’s interesting to note that there has been several attempts to tackle this problem or a problem in this family, starting with ``Autofield``. This attempt follows the DEP procedure in hope that it will help reaching a more satisfying state.

While there are several mentions to database-level default values, database triggers, database views, etc., this PEP does not contain those features, but tries to create an environment where they will be easier to implement at a later step.

The two next subsections will highlight cases that are currently problematic in Django without those features.

Readonly (a case study)
-----------------------

Say we have :

.. code-block:: python

    class Author(models.Model):
        name = models.CharField(max_length=100)

    class Books(models.Model):
        author = models.ForeignKey(Author)
        number_sold = models.IntegerField()

We have many ``Authors`` and each of them have many ``Books``. It starts becoming tedious to count the number of ``Books`` sold by each ``Author``. This is something we need to do quite often because the top selling authors are displayed in real time on our home page.

We decide to add a column on the ``Author`` model :

.. code-block:: python

    total_books_sold = models.IntegerField()


And, as we want to make sure the new field is always up to date, we write a database trigger that will update its value everytime a Book is updated.

A few weeks pass, and we discover that, sometimes, the ``total_books_sold`` is off. This is strange, because we have audited our code and we are sure that we never change the value of this field. We start to wonder if our triggers work correctly, and then we realize that when we do:

.. code-block:: python


    author = Author.objects.get(name="Terry Pratchett")
    author.name = "Sir " + author.name
    author.save()


... and if there was an update of ``total_books_sold`` by the database between our ``get`` and our ``save`` we have probably overwritten the value with our old value.

The readonly feature as described above would have prevented that. It would also have helped us realize that we were doing things like:

.. code-block:: python

    terry_pratchett.total_books_sold = 12
    # or
    Authors.objects.filter(name="Terry Pratchett").update(total_books_sold=12)
    # or
    Authors.objects.create(name="Terry Pratchett", total_books_sold=12)

which most probably were wrong.

Auto-refresh
------------

When fields are readonly, auto-refresh is an important thing to keep the Model instances synced with the data in the database. Auto-refresh tries to go to the simplest path for doing that.

Rationale
=========

Here are the different use cases identified for which this DEP would help:

- Database defaults would benefit from auto-refresh;
- Database triggers would benefit from auto-refresh and readonly;
- Postgres Serial fields may benefit from auto-refresh and optionally from readonly;
- Autofield could be refactored around auto-refresh for PostgreSQL and Oracle;
- Database views and materialized views will benefit from both readonly and auto-refresh;
- A cleaner and broader implementation of Autofields (and primary fields in general) will benefit from auto-refresh;
- A Django implementation of Serial fields, or UUID fields would benefit from auto-refresh and, in some case, readonly too.
- ...

While these 2 features don't solve the whole problem, they really seem to be the common thread that will help Django go forward.

The following sections outline some design discussions and decisions, and the reasons behind them.

Readonly
--------

AutoField / primary key
^^^^^^^^^^^^^^^^^^^^^^^

While not specifically useful, there's no reason to say the AutoField of a Model should or should not be readonly. AutoField will not be a special case for Readonly. This is clearly the kind of things that the Database will fill for us to ensure uniqueness, and there are not so many cases where we really want to choose the primary key or update the primary key (plus, that might be complex to deal with if we have ``ForeignKeys``)

The ``INSERT`` problem
^^^^^^^^^^^^^^^^^^^^^^

One cannot omit a required Field on an ``INSERT`` query. Readonly fields will always be omitted. This means that readonly Fields cannot be required by the database. They need to be ``null=True`` or have a database default or not really be fields in the first place. For now, of all these  possibilities, the only one Django can do is the nullable Field, but it's likely not what people want.

This means that, as of today, people using readonly Fields have to define the Field manually themselves, probably using an SQL migration. It's not a "problem", but it's something unusual. It's also logical that, because the DEP goes toward leaving the responsibility of this field to the Database, the responsibility of defining this Field also goes to the Database.

Backdoor
^^^^^^^^

We could imagine different systems that would allow actually including the readonly fields for ``INSERT`` or ``UPDATES``. As of now, a use-case has not been presented demonstrating the need for one.

Warnings
^^^^^^^^

The authors of the DEP are not aware of a preference between ``warnings`` (as in ``import warning``) or ``logs`` (as in ``logging.warning()``) as far of Django's own codebase goes.

Serialization
^^^^^^^^^^^^^

As of now, a use-case has not been presented demonstrating the need for either excluding readonly fields from serialization or including them for deserialization.


Auto-refresh
------------

The ``SELECT`` query
^^^^^^^^^^^^^^^^^^^^

Several propositions have been made for databases that don't support ``RETURNING``:

- We should do the ``SELECT`` query right away (using ``refresh_from_db(fields=readonly_fields)`` for example);
- Or we should have these fields be lazily fetched upon use (all together or individually, marking them as deferred);
- Or we should provide a default behaviour (say, refresh) and a mechanism to do otherwise (say ``.save(auto_refresh=False)``);
- Or we should do nothing and let the user explicitly refresh the fields they want.

In the end, the recent refactor of deferred fields really pointed us towards this solution for its simplicity, both to implement and to use.

Existing works
==============

Unimplemented Tickets
---------------------

`#27446`_
^^^^^^^^^
(Nov. 2016) A ticket (by the authors of this DEP) on implementing the readonly argument. Closed in favor of `#21454`_.

Implemented tickets
-------------------

`#21454`_
^^^^^^^^^
(Jan. 2014) A ticket by @mpessas explaining the problem (database-generated values, triggers, virtual fields).
The tickets refers a lot to the proposed implementation (see below).
The ensuing discussion highlights several points :

- There are both arguments for and against making an extra fetch query
  after the ``INSERT`` / ``UPDATE``. It’s probably important to give
  the user the choice. When using ``RETURNING`` on the backends that support it,
  it’s quite less problematic.
- On this ticket, neither the ``.update()`` method nor fixture loading
  enforced the behavior of not writing the fields into the database.
- The possibility of having one field be written to the database for
  ``INSERT``but not for ``UPDATE`` or vice versa is mentionned.
- It also mentions the need for having the refresh behaviour somewhat
  independent from the readonly behaviour.

Implemented in `GitHub #2149`_
""""""""""""""""""""""""""""""
(Nov. 2013 > Feb. 2104) By @mpessas too.
Corresponding implementation to the ticket above, containing a lot of advice by @shaib, both specific to this implementation and more generally to how ``RETURNING`` works for different backends.
In this implementation :

- modifying the ``save`` method to remove unwanted fields (readonly);
- a lot of work had to be done to properly implement the refreshing part
  (auto_refresh)

This PR was closed for inactivity.

Implemented in `GitHub #5904`_
""""""""""""""""""""""""""""""
(Dec. 2015) By @owais. A new implementation. This PR works by modifying the queryset API to add ``add/get_ignore_delegated()`` methods that will add fields on an ``_ignore_delegated`` list which is passed to ``.save()`` to ignore the fields. Its stand is that ignoring those fields or not is something that should be chosen when calling save / create.
This PR also provides a new API on the fields with five new options (four behavior flags and a fifth on that is a shortcut for all of those flags).

This PR spawned the discussion `[Review Request] Added support for database delegated fields (like AutoField)`_ on the Dev mailing list (see below).

This PR was closed for inactivity too.

Implemented in `GitHub #7515`_
""""""""""""""""""""""""""""""

(Nov. 2016) By the authors of this DEP. This implementations was based on `Django Readonly Field <https://github.com/novafloss/django-readonly-field>`_. At start, it was just an implementation for the "readonly" part, but there was a take at adding the "auto-refresh" as a later move. There was also an interesting suggestion of not refreshing in the field, but one way or another (e.g. using the already existing ``deferred`` feature) having these fields be lazily fetched from the database.

This PR was suspended while writing this DEP.

`#470`_
^^^^^^^

An old closed ticket which was the first one suggesting the use of database defaults.

Discussions on the Django Developers Mailing list
-------------------------------------------------

`[Review Request] Added support for database delegated fields (like AutoField)`_
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This discussion mainly advocates that the API proposed in `GitHub #5904`_ is too complicated. It also points towards the work on _`default values on database level`_.

_`default values on database level`
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Talking specifically about default values, as the title says, an agreed-upon behaviour seems to be a ``db_defaut`` option on the fields. This feature could use the auto-refresh behaviour described in this DEP, but for the rest, it’s probably not directly linked. It references `#470`_.

..
  Links
  -----

.. _`[Review Request] Added support for database delegated fields (like AutoField)`: https://groups.google.com/forum/#!msg/django-developers/BDAlTyJwQeY/BOuTv5AHEgAJ
.. _`default values on database level`: https://groups.google.com/forum/#!topic/django-developers/3mcro17Gb40/discussion
.. _`#470`: https://code.djangoproject.com/ticket/470
.. _`#27446`: https://code.djangoproject.com/ticket/27446
.. _`#21454`: https://code.djangoproject.com/ticket/21454
.. _`GitHub #2149`: https://github.com/django/django/pull/2149
.. _`GitHub #5904`: https://github.com/django/django/pull/5904
.. _`GitHub #7515`: https://github.com/django/django/pull/7515

Backwards Compatibility
=======================

This DEP will not change existing behaviours, it will only add new behaviour using opt-in flags. It should not need a deprecation path.

Reference Implementation
========================

An implementation is being written by the authors of the DEP to try and experiment with the API. A PR will be opened when ready.

Copyright
=========

This document has been placed in the public domain per the Creative Commons
CC0 1.0 Universal license (http://creativecommons.org/publicdomain/zero/1.0/deed).
